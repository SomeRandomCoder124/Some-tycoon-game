-- [[Services]] --
local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Teams = game:GetService("Teams")

-- [[Variables]] --
local Map = workspace:WaitForChild("Map")
local building = ServerStorage.Building
local buttons = ServerStorage.Buttons
local events = ReplicatedStorage.Events
local purchase = ReplicatedStorage.Events.Purchase

-- [[Tables]] --
-- table for the owners of the tycoon
local workingModel = {}
local OwnerList = {
	["Blue"] = {
		["PlayerName"] = "",
		["Color"] = BrickColor.new(0, 0.525, 1),
	},
	["Red"] = {
		["PlayerName"] = "",
		["Color"] = BrickColor.new(1, 0, 0.0156863),
	},
	["Violet"] = {
		["PlayerName"] = "",
		["Color"] = BrickColor.new(0.165, 0, 0.59),
	},
	["Green"] = {
		["PlayerName"] = "",
		["Color"] = BrickColor.new(0, 1, 0),
	},
}

-- [[Functions]] --
-- for tycoon
function Build(Map)
	purchase.Event:Connect(function(Owner, Button)
		local base = Map[Players[Owner].Team.Name].Parts.Base

		local buildPart = building[Button]:Clone()
		buildPart.Parent = base.Parent.Parent.Parts

		local thePosition = ThePosition(buildPart, building.Base, base)
		local theRotation = Rotation(building[Button], building.Base, base)

		buildPart:PivotTo(thePosition * theRotation)

		local weld = Instance.new("Weld", base)
		weld.Part0 = base
		if buildPart:IsA("Model") then
			weld.Part1 = buildPart.PrimaryPart
		else
			weld.Part1 = buildPart
		end

		base.Parent.Parent.Buttons[Button]:Destroy()

		if buildPart:FindFirstChild("Type") and buildPart.Type:IsA("StringValue") then
			workingModel[buildPart.Type.Value](buildPart)
		end
	end)
end

function Button(Owner, base, currentFloor)
	if not buttons:FindFirstChild("Floor "..currentFloor) then return end

	local debounce = false
	local theButtons = buttons["Floor "..currentFloor]

	for i, allButtons in pairs(theButtons:GetChildren()) do
		local clonedButton = allButtons:Clone()
		clonedButton.PrimaryPart.Anchored = true
		clonedButton.Parent = base.Parent.Parent.Buttons

		local priceGui = ServerStorage.Guis.PriceGui:Clone()
		priceGui.Parent = clonedButton
		priceGui.PriceLabel.Text = "$"..clonedButton.Price.Value

		local thePosition = ThePosition(clonedButton,building.Base,base)
		local theRotation = Rotation(clonedButton, building.Base, base)
		clonedButton:PivotTo(thePosition * theRotation)

		local activeFunction
		activeFunction = clonedButton.PrimaryPart.Touched:Connect(function(hit)
			if debounce == false and hit.Parent:FindFirstChild("Humanoid") then
				local plrTeam = Players[hit.Parent.Name].Team.Name

				if plrTeam ~= base.Parent.Parent.Name then return end
				if Players[Owner].leaderstats.Cash.Value >= clonedButton.Price.Value then
					debounce = true
					purchase:Fire(Owner, clonedButton.Name)
					Players[Owner].leaderstats.Cash.Value -= clonedButton.Price.Value
					task.wait(0.01)

					if #base.Parent.Parent.Buttons:GetChildren() <= 0 then
						currentFloor += 1
						--activeFunction:Disconnect()
						Button(Owner, base, currentFloor)
					end

					activeFunction:Disconnect()
					debounce = false
				end
			end
		end)
	end
end

-- to calculate the position of buttons and model that pivot after purchasing, currently can't rotate
function ThePosition(buildPart, part1, part2)
	local result = 0
	local x = 0
	local y = 0
	local z = 0

	local currentModel = buildPart:GetPivot()
	local PtPosition1 = part1.Position
	local PtPosition2 = part2.Position
	local theBuildedPart = nil

	if buildPart:IsA("Model") then
		theBuildedPart = currentModel.Position
	elseif buildPart:IsA("Part")
		or buildPart:IsA("UnionOperation")
		or buildPart:IsA("Mesh")
	then
		theBuildedPart = buildPart.Position
	end

	if part2.Position.X >= part1.Position.X then
		x = theBuildedPart.X + (PtPosition2.X-PtPosition1.X)
	else
		x = theBuildedPart.X - (math.abs(PtPosition2.X)+PtPosition1.X)
	end
	if part2.Position.Y >= part1.Position.Y then
		y = theBuildedPart.Y + (PtPosition2.Y-PtPosition1.Y)
	else
		y = theBuildedPart.Y - (math.abs(PtPosition2.Y)+PtPosition1.Y)
	end
	if part2.Position.Z >= part1.Position.Z then
		z = theBuildedPart.Z + (PtPosition2.Z-PtPosition1.Z)
	else
		z = theBuildedPart.Z - (math.abs(PtPosition2.Z)+PtPosition1.Z)
	end
	result = CFrame.new(Vector3.new(x,y,z))

	return result
end

function Rotation(buildPart, part1, part2)
	local result = 0
	local x = 0
	local y = 0
	local z = 0

	local PtRotation1 = part1.Orientation
	local PtRotation2 = part2.Orientation
	local theBuildedPart = nil

	if buildPart:IsA("Model") then
		theBuildedPart = buildPart.PrimaryPart.Orientation
	elseif buildPart:IsA("Part")
		or buildPart:IsA("UnionOperation")
		or buildPart:IsA("Mesh")
	then
		theBuildedPart = buildPart.Orientation
	end

	if part2.Orientation.X >= part1.Orientation.X then
		x = theBuildedPart.X + (PtRotation2.X-PtRotation1.X)
	else
		x = theBuildedPart.X - (math.abs(PtRotation2.X)+PtRotation1.X)
	end
	if part2.Orientation.Y >= part1.Orientation.Y then
		y = theBuildedPart.Y + (PtRotation2.Y-PtRotation1.Y)
	else
		y = theBuildedPart.Y - (math.abs(PtRotation2.Y)+PtRotation1.Y)
	end
	if part2.Orientation.Z >= part1.Orientation.Z then
		z = theBuildedPart.Z + (PtRotation2.Z-PtRotation1.Z)
	else
		z = theBuildedPart.Z - (math.abs(PtRotation2.Z)+PtRotation1.Z)
	end

	result = CFrame.Angles(math.rad(x),math.rad(y),math.rad(z))

	return result
end

-- for working models like droppers and convoyer
function workingModel.Dropper(dropper)
	local timeRate = dropper.DropRate.Value
	local counter = 0

	RunService.Heartbeat:Connect(function(deltaTime)
		counter = counter + deltaTime

		if counter >= timeRate then
			counter = counter - timeRate

			local part = Instance.new("Part")
			part.Parent = dropper.Parent.Parent.IncomeOrbs
			part.Name = "Research Orb"
			part.Color = Color3.new(0.235294, 0, 1)
			part.Material=("Neon")
			part.CFrame = dropper.Drop.CFrame - Vector3.new(0,1.4,0)
			part.Size=Vector3.new(1, 1, 1) -- Size of the drops
			part.Shape = Enum.PartType.Ball
			part.Anchored = false
			part.CanCollide = true
			part.CollisionGroup = "Orbs"
			game.Debris:AddItem(part,8)
			local orbValue = Instance.new("IntValue")
			orbValue.Parent = part
			orbValue.Name = "Income"
			orbValue.Value = dropper.Income.Value
		end
	end)
end

function workingModel.Convoyer(convoyer)
	local debounce = false
	local playerCash = Players[convoyer.Parent.Parent.Owner.Value].leaderstats.Cash
	local speed = convoyer.Speed.Value

	RunService.Stepped:Connect(function(deltaTime)
		convoyer.convoyer_belt.Velocity = convoyer.convoyer_belt.CFrame.lookVector * speed
	end)

	convoyer.CashPlate.Touched:Connect(function(hit)
		if debounce == false then
			if hit:IsA("Part") and hit.Name == "Research Orb" then
				debounce = true
				playerCash.Value += hit:WaitForChild("Income").Value
				hit:Destroy()
				task.wait()
				debounce = false
			end
		end
	end)
end

-- [[Main]] --
Build(Map)

Players.PlayerAdded:Connect(function(player)
	local leaderstats = Instance.new("Folder")
	leaderstats.Name = "leaderstats"
	leaderstats.Parent = player

	local currency = Instance.new("IntValue")
	currency.Name = "Cash"
	currency.Parent = leaderstats
	currency.Value = 0
end)

for i, teams in pairs(OwnerList) do
	local team = Instance.new("Team")
	team.Name = i
	team.TeamColor = teams.Color
	team.Parent = Teams
	team.AutoAssignable = false
end

for i, tycoon in pairs(Map:GetChildren()) do
	local defaultFloor = 1

	local buttons = Instance.new("Folder")
	buttons.Name = "Buttons"
	buttons.Parent = tycoon

	local incomeOrbs = Instance.new("Folder")
	incomeOrbs.Name = "IncomeOrbs"
	incomeOrbs.Parent = tycoon

	local parts = Instance.new("Folder")
	parts.Name = "Parts"
	parts.Parent = tycoon
	tycoon:WaitForChild("Base").Parent = parts
	parts.Base.Anchored = true


	local tycoonOwner = Instance.new("StringValue")
	tycoonOwner.Name = "Owner"
	tycoonOwner.Parent = tycoon
	tycoonOwner.Value = ""

	local claimPart = building.ClaimBase:Clone()
	claimPart.Parent = parts
	local thePosition = ThePosition(claimPart, building.Base, parts.Base)
	local theRotation = Rotation(claimPart, building.Base, parts.Base)
	claimPart:PivotTo(thePosition * theRotation)
	
	local debounce = false
	local claimFunction
	claimFunction = claimPart.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChild("Humanoid") then
			if not Players[hit.Parent.Name].Team
				and (claimPart.Parent.Parent.Owner.Value == nil
					or claimPart.Parent.Parent.Owner.Value == "")
			then
				if debounce == false then
					debounce = true

					local theBase = claimPart.Parent.Parent.Parts.Base

					Players[hit.Parent.Name].Team = Teams[claimPart.Parent.Parent.Name]
					OwnerList[tycoon.Name]["PlayerName"] = hit.Parent.Name
					claimPart.Parent.Parent.Owner.Value = hit.Parent.Name
					claimPart.OwnerGui.NameLabel.Text = "Owner: "..hit.Parent.Name
					claimPart.Transparency = 1

					Button(hit.Parent.Name, theBase, defaultFloor)

					--claimFunction:Disconnect()

					debounce = false
				end
			end	
		end
	end)
end

-- Remove thing and datesaving on leaving not exist yet
